package models

// Code generated by xo. DO NOT EDIT.

import (
	"context"
)

// Constraint represents all constraints in a schema.
type Constraint struct {
	KeyType          string `json:"key_type"`           // key_type
	UniqueKeyName    string `json:"unique_key_name"`    // unique_key_name
	TableName        string `json:"table_name"`         // table_name
	TableSchema      string `json:"table_schema"`       // table_schema
	ColumnName       string `json:"column_name"`        // column_name
	TableComment     string `json:"table_comment"`      // table_comment
	ColumnComment    string `json:"column_comment"`     // column_comment
	RefColumnComment string `json:"ref_column_comment"` // ref_column_comment
	RefTableSchema   string `json:"ref_table_schema"`   // ref_table_schema
	RefTableName     string `json:"ref_table_name"`     // ref_table_name
	RefColumnName    string `json:"ref_column_name"`    // ref_column_name
}

// PostgresConstraints runs a custom query, returning results as Constraint.
func PostgresConstraints(ctx context.Context, db DB, schema string) ([]*Constraint, error) {
	// query
	const sqlstr = `SELECT ` +
		`distinct (CASE tc.constraint_type ` +
		`WHEN 'UNIQUE' THEN 'unique' ` +
		`WHEN 'CHECK' THEN 'check' ` +
		`WHEN 'PRIMARY KEY' THEN 'primary_key' ` +
		`WHEN 'FOREIGN KEY' THEN 'foreign_key' ` +
		`END), ` + // ::varchar AS key_type
		`tc.constraint_name, ` + // ::varchar AS unique_key_name
		`tc.table_name as table_name, ` +
		`tc.table_schema as table_schema, ` +
		`kcu.column_name, ` + // ::varchar AS column_name
		`COALESCE(obj_description(format('%s.%s',c.table_schema,c.table_name)::regclass::oid, 'pg_class'), '') as table_comment, ` +
		`COALESCE(col_description(format('%s.%s',c.table_schema,c.table_name)::regclass::oid, c.ordinal_position::int), '') as column_comment, ` +
		`COALESCE(col_description(format('%s.%s',ccu.table_schema,ccu.table_name)::regclass::oid, ccu.ordinal_position::int), '') as ref_column_comment, ` +
		`ccu.table_schema, ` + // ::varchar AS ref_table_schema
		`ccu.table_name, ` + // ::varchar AS ref_table_name
		`ccu.column_name ` + // ::varchar AS ref_column_name
		`FROM information_schema.table_constraints tc ` +
		`JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name ` +
		`AND tc.table_schema = kcu.table_schema ` +
		`join information_schema.columns as c on tc.table_name = c.table_name and c.column_name = kcu.column_name ` +
		`JOIN ( ` +
		`SELECT ` +
		`ROW_NUMBER() OVER ( ` +
		`PARTITION BY ` +
		`table_schema, ` +
		`table_name, ` +
		`constraint_name ` +
		`ORDER BY row_num ` +
		`) AS ordinal_position, ` +
		`table_schema, ` +
		`table_name, ` +
		`column_name, ` +
		`constraint_name ` +
		`FROM ( ` +
		`SELECT ` +
		`ROW_NUMBER() OVER (ORDER BY 1) AS row_num, ` +
		`table_schema, ` +
		`table_name, ` +
		`column_name, ` +
		`constraint_name ` +
		`FROM information_schema.constraint_column_usage ` +
		`) t ` +
		`) AS ccu ON ccu.constraint_name = tc.constraint_name ` +
		`AND ccu.table_schema = tc.table_schema ` +
		`AND ccu.ordinal_position = kcu.ordinal_position ` +
		`WHERE tc.table_schema = $1`
	// run
	logf(sqlstr, schema)
	rows, err := db.QueryContext(ctx, sqlstr, schema)
	if err != nil {
		return nil, logerror(err)
	}
	defer rows.Close()
	// load results
	var res []*Constraint
	for rows.Next() {
		var c Constraint
		// scan
		if err := rows.Scan(&c.KeyType, &c.UniqueKeyName, &c.TableName, &c.TableSchema, &c.ColumnName, &c.TableComment, &c.ColumnComment, &c.RefColumnComment, &c.RefTableSchema, &c.RefTableName, &c.RefColumnName); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &c)
	}
	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}
