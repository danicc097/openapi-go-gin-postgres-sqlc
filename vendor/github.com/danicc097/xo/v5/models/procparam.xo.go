package models

// Code generated by xo. DO NOT EDIT.

import (
	"context"
)

// ProcParam is a stored procedure param.
type ProcParam struct {
	ParamName string `json:"param_name"` // param_name
	ParamType string `json:"param_type"` // param_type
}

// PostgresProcParams runs a custom query, returning results as ProcParam.
func PostgresProcParams(ctx context.Context, db DB, schema, id string) ([]*ProcParam, error) {
	// query
	const sqlstr = `SELECT ` +
		`COALESCE(pp.param_name, ''), ` + // ::varchar AS param_name
		`pp.param_type ` + // ::varchar AS param_type
		`FROM pg_proc p ` +
		`JOIN ONLY pg_namespace n ON p.pronamespace = n.oid ` +
		`JOIN ( ` +
		`SELECT ` +
		`p.oid, ` +
		`UNNEST(p.proargnames) AS param_name, ` +
		`format_type(UNNEST(p.proargtypes), NULL) AS param_type ` +
		`FROM pg_proc p ` +
		`) AS pp ON p.oid = pp.oid ` +
		`WHERE n.nspname = $1 ` +
		`AND p.oid::varchar = $2 ` +
		`AND pp.param_type IS NOT NULL`
	// run
	logf(sqlstr, schema, id)
	rows, err := db.QueryContext(ctx, sqlstr, schema, id)
	if err != nil {
		return nil, logerror(err)
	}
	defer rows.Close()
	// load results
	var res []*ProcParam
	for rows.Next() {
		var pp ProcParam
		// scan
		if err := rows.Scan(&pp.ParamName, &pp.ParamType); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &pp)
	}
	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}
