package models

// Code generated by xo. DO NOT EDIT.

import (
	"context"
	"database/sql"
)

// Column is a column.
type Column struct {
	FieldOrdinal  int            `json:"field_ordinal"`  // field_ordinal
	ColumnName    string         `json:"column_name"`    // column_name
	DataType      string         `json:"data_type"`      // data_type
	NotNull       bool           `json:"not_null"`       // not_null
	DefaultValue  sql.NullString `json:"default_value"`  // default_value
	IsPrimaryKey  bool           `json:"is_primary_key"` // is_primary_key
	ColumnComment string         `json:"column_comment"` // column_comment
}

// PostgresTableColumns runs a custom query, returning results as Column.
func PostgresTableColumns(ctx context.Context, db DB, schema, table string, sys bool) ([]*Column, error) {
	// query
	const sqlstr = `SELECT DISTINCT ` +
		`a.attnum, ` + // ::integer AS field_ordinal
		`a.attname, ` + // ::varchar AS column_name
		`format_type(a.atttypid, a.atttypmod), ` + // ::varchar AS data_type
		`a.attnotnull, ` + // ::boolean AS not_null
		`COALESCE(pg_get_expr(ad.adbin, ad.adrelid), ''), ` + // ::varchar AS default_value
		`COALESCE(ct.contype = 'p', false), ` + // ::boolean AS is_primary_key
		`COALESCE(col_description(format('%s.%s', n.nspname, c.relname)::regclass::oid, isc.ordinal_position), '') as column_comment ` +
		`FROM pg_attribute a ` +
		`JOIN ONLY pg_class c ON c.oid = a.attrelid ` +
		`JOIN ONLY pg_namespace n ON n.oid = c.relnamespace ` +
		`INNER JOIN information_schema.columns as isc on c.relname = isc.table_name and isc.column_name = a.attname and isc.table_schema = $1 ` +
		`LEFT JOIN pg_constraint ct ON ct.conrelid = c.oid ` +
		`AND a.attnum = ANY(ct.conkey) ` +
		`AND ct.contype = 'p' ` +
		`LEFT JOIN pg_attrdef ad ON ad.adrelid = c.oid ` +
		`AND ad.adnum = a.attnum ` +
		`WHERE a.attisdropped = false ` +
		`AND n.nspname = $1 ` +
		`AND c.relname = $2 ` +
		`AND ($3 OR a.attnum > 0) ` +
		`ORDER BY a.attnum`
	// run
	logf(sqlstr, schema, table, sys)
	rows, err := db.QueryContext(ctx, sqlstr, schema, table, sys)
	if err != nil {
		return nil, logerror(err)
	}
	defer rows.Close()
	// load results
	var res []*Column
	for rows.Next() {
		var c Column
		// scan
		if err := rows.Scan(&c.FieldOrdinal, &c.ColumnName, &c.DataType, &c.NotNull, &c.DefaultValue, &c.IsPrimaryKey, &c.ColumnComment); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &c)
	}
	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}
