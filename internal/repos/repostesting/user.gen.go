// Code generated by counterfeiter. DO NOT EDIT.
package repostesting

import (
	"context"
	"sync"

	"github.com/danicc097/openapi-go-gin-postgres-sqlc/internal/repos"
	"github.com/danicc097/openapi-go-gin-postgres-sqlc/internal/repos/postgresql/gen/models"
)

type FakeUser struct {
	ByAPIKeyStub        func(context.Context, models.DBTX, string) (*models.User, error)
	byAPIKeyMutex       sync.RWMutex
	byAPIKeyArgsForCall []struct {
		arg1 context.Context
		arg2 models.DBTX
		arg3 string
	}
	byAPIKeyReturns struct {
		result1 *models.User
		result2 error
	}
	byAPIKeyReturnsOnCall map[int]struct {
		result1 *models.User
		result2 error
	}
	ByEmailStub        func(context.Context, models.DBTX, string, ...models.UserSelectConfigOption) (*models.User, error)
	byEmailMutex       sync.RWMutex
	byEmailArgsForCall []struct {
		arg1 context.Context
		arg2 models.DBTX
		arg3 string
		arg4 []models.UserSelectConfigOption
	}
	byEmailReturns struct {
		result1 *models.User
		result2 error
	}
	byEmailReturnsOnCall map[int]struct {
		result1 *models.User
		result2 error
	}
	ByExternalIDStub        func(context.Context, models.DBTX, string, ...models.UserSelectConfigOption) (*models.User, error)
	byExternalIDMutex       sync.RWMutex
	byExternalIDArgsForCall []struct {
		arg1 context.Context
		arg2 models.DBTX
		arg3 string
		arg4 []models.UserSelectConfigOption
	}
	byExternalIDReturns struct {
		result1 *models.User
		result2 error
	}
	byExternalIDReturnsOnCall map[int]struct {
		result1 *models.User
		result2 error
	}
	ByIDStub        func(context.Context, models.DBTX, models.UserID, ...models.UserSelectConfigOption) (*models.User, error)
	byIDMutex       sync.RWMutex
	byIDArgsForCall []struct {
		arg1 context.Context
		arg2 models.DBTX
		arg3 models.UserID
		arg4 []models.UserSelectConfigOption
	}
	byIDReturns struct {
		result1 *models.User
		result2 error
	}
	byIDReturnsOnCall map[int]struct {
		result1 *models.User
		result2 error
	}
	ByProjectStub        func(context.Context, models.DBTX, models.ProjectID) ([]models.User, error)
	byProjectMutex       sync.RWMutex
	byProjectArgsForCall []struct {
		arg1 context.Context
		arg2 models.DBTX
		arg3 models.ProjectID
	}
	byProjectReturns struct {
		result1 []models.User
		result2 error
	}
	byProjectReturnsOnCall map[int]struct {
		result1 []models.User
		result2 error
	}
	ByTeamStub        func(context.Context, models.DBTX, models.TeamID) ([]models.User, error)
	byTeamMutex       sync.RWMutex
	byTeamArgsForCall []struct {
		arg1 context.Context
		arg2 models.DBTX
		arg3 models.TeamID
	}
	byTeamReturns struct {
		result1 []models.User
		result2 error
	}
	byTeamReturnsOnCall map[int]struct {
		result1 []models.User
		result2 error
	}
	ByUsernameStub        func(context.Context, models.DBTX, string, ...models.UserSelectConfigOption) (*models.User, error)
	byUsernameMutex       sync.RWMutex
	byUsernameArgsForCall []struct {
		arg1 context.Context
		arg2 models.DBTX
		arg3 string
		arg4 []models.UserSelectConfigOption
	}
	byUsernameReturns struct {
		result1 *models.User
		result2 error
	}
	byUsernameReturnsOnCall map[int]struct {
		result1 *models.User
		result2 error
	}
	CreateStub        func(context.Context, models.DBTX, *models.UserCreateParams) (*models.User, error)
	createMutex       sync.RWMutex
	createArgsForCall []struct {
		arg1 context.Context
		arg2 models.DBTX
		arg3 *models.UserCreateParams
	}
	createReturns struct {
		result1 *models.User
		result2 error
	}
	createReturnsOnCall map[int]struct {
		result1 *models.User
		result2 error
	}
	CreateAPIKeyStub        func(context.Context, models.DBTX, *models.User) (*models.UserAPIKey, error)
	createAPIKeyMutex       sync.RWMutex
	createAPIKeyArgsForCall []struct {
		arg1 context.Context
		arg2 models.DBTX
		arg3 *models.User
	}
	createAPIKeyReturns struct {
		result1 *models.UserAPIKey
		result2 error
	}
	createAPIKeyReturnsOnCall map[int]struct {
		result1 *models.UserAPIKey
		result2 error
	}
	DeleteStub        func(context.Context, models.DBTX, models.UserID) (*models.User, error)
	deleteMutex       sync.RWMutex
	deleteArgsForCall []struct {
		arg1 context.Context
		arg2 models.DBTX
		arg3 models.UserID
	}
	deleteReturns struct {
		result1 *models.User
		result2 error
	}
	deleteReturnsOnCall map[int]struct {
		result1 *models.User
		result2 error
	}
	DeleteAPIKeyStub        func(context.Context, models.DBTX, string) (*models.UserAPIKey, error)
	deleteAPIKeyMutex       sync.RWMutex
	deleteAPIKeyArgsForCall []struct {
		arg1 context.Context
		arg2 models.DBTX
		arg3 string
	}
	deleteAPIKeyReturns struct {
		result1 *models.UserAPIKey
		result2 error
	}
	deleteAPIKeyReturnsOnCall map[int]struct {
		result1 *models.UserAPIKey
		result2 error
	}
	PaginatedStub        func(context.Context, models.DBTX, repos.GetPaginatedUsersParams) ([]models.User, error)
	paginatedMutex       sync.RWMutex
	paginatedArgsForCall []struct {
		arg1 context.Context
		arg2 models.DBTX
		arg3 repos.GetPaginatedUsersParams
	}
	paginatedReturns struct {
		result1 []models.User
		result2 error
	}
	paginatedReturnsOnCall map[int]struct {
		result1 []models.User
		result2 error
	}
	UpdateStub        func(context.Context, models.DBTX, models.UserID, *models.UserUpdateParams) (*models.User, error)
	updateMutex       sync.RWMutex
	updateArgsForCall []struct {
		arg1 context.Context
		arg2 models.DBTX
		arg3 models.UserID
		arg4 *models.UserUpdateParams
	}
	updateReturns struct {
		result1 *models.User
		result2 error
	}
	updateReturnsOnCall map[int]struct {
		result1 *models.User
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeUser) ByAPIKey(arg1 context.Context, arg2 models.DBTX, arg3 string) (*models.User, error) {
	fake.byAPIKeyMutex.Lock()
	ret, specificReturn := fake.byAPIKeyReturnsOnCall[len(fake.byAPIKeyArgsForCall)]
	fake.byAPIKeyArgsForCall = append(fake.byAPIKeyArgsForCall, struct {
		arg1 context.Context
		arg2 models.DBTX
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.ByAPIKeyStub
	fakeReturns := fake.byAPIKeyReturns
	fake.recordInvocation("ByAPIKey", []interface{}{arg1, arg2, arg3})
	fake.byAPIKeyMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeUser) ByAPIKeyCallCount() int {
	fake.byAPIKeyMutex.RLock()
	defer fake.byAPIKeyMutex.RUnlock()
	return len(fake.byAPIKeyArgsForCall)
}

func (fake *FakeUser) ByAPIKeyCalls(stub func(context.Context, models.DBTX, string) (*models.User, error)) {
	fake.byAPIKeyMutex.Lock()
	defer fake.byAPIKeyMutex.Unlock()
	fake.ByAPIKeyStub = stub
}

func (fake *FakeUser) ByAPIKeyArgsForCall(i int) (context.Context, models.DBTX, string) {
	fake.byAPIKeyMutex.RLock()
	defer fake.byAPIKeyMutex.RUnlock()
	argsForCall := fake.byAPIKeyArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeUser) ByAPIKeyReturns(result1 *models.User, result2 error) {
	fake.byAPIKeyMutex.Lock()
	defer fake.byAPIKeyMutex.Unlock()
	fake.ByAPIKeyStub = nil
	fake.byAPIKeyReturns = struct {
		result1 *models.User
		result2 error
	}{result1, result2}
}

func (fake *FakeUser) ByAPIKeyReturnsOnCall(i int, result1 *models.User, result2 error) {
	fake.byAPIKeyMutex.Lock()
	defer fake.byAPIKeyMutex.Unlock()
	fake.ByAPIKeyStub = nil
	if fake.byAPIKeyReturnsOnCall == nil {
		fake.byAPIKeyReturnsOnCall = make(map[int]struct {
			result1 *models.User
			result2 error
		})
	}
	fake.byAPIKeyReturnsOnCall[i] = struct {
		result1 *models.User
		result2 error
	}{result1, result2}
}

func (fake *FakeUser) ByEmail(arg1 context.Context, arg2 models.DBTX, arg3 string, arg4 ...models.UserSelectConfigOption) (*models.User, error) {
	fake.byEmailMutex.Lock()
	ret, specificReturn := fake.byEmailReturnsOnCall[len(fake.byEmailArgsForCall)]
	fake.byEmailArgsForCall = append(fake.byEmailArgsForCall, struct {
		arg1 context.Context
		arg2 models.DBTX
		arg3 string
		arg4 []models.UserSelectConfigOption
	}{arg1, arg2, arg3, arg4})
	stub := fake.ByEmailStub
	fakeReturns := fake.byEmailReturns
	fake.recordInvocation("ByEmail", []interface{}{arg1, arg2, arg3, arg4})
	fake.byEmailMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeUser) ByEmailCallCount() int {
	fake.byEmailMutex.RLock()
	defer fake.byEmailMutex.RUnlock()
	return len(fake.byEmailArgsForCall)
}

func (fake *FakeUser) ByEmailCalls(stub func(context.Context, models.DBTX, string, ...models.UserSelectConfigOption) (*models.User, error)) {
	fake.byEmailMutex.Lock()
	defer fake.byEmailMutex.Unlock()
	fake.ByEmailStub = stub
}

func (fake *FakeUser) ByEmailArgsForCall(i int) (context.Context, models.DBTX, string, []models.UserSelectConfigOption) {
	fake.byEmailMutex.RLock()
	defer fake.byEmailMutex.RUnlock()
	argsForCall := fake.byEmailArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeUser) ByEmailReturns(result1 *models.User, result2 error) {
	fake.byEmailMutex.Lock()
	defer fake.byEmailMutex.Unlock()
	fake.ByEmailStub = nil
	fake.byEmailReturns = struct {
		result1 *models.User
		result2 error
	}{result1, result2}
}

func (fake *FakeUser) ByEmailReturnsOnCall(i int, result1 *models.User, result2 error) {
	fake.byEmailMutex.Lock()
	defer fake.byEmailMutex.Unlock()
	fake.ByEmailStub = nil
	if fake.byEmailReturnsOnCall == nil {
		fake.byEmailReturnsOnCall = make(map[int]struct {
			result1 *models.User
			result2 error
		})
	}
	fake.byEmailReturnsOnCall[i] = struct {
		result1 *models.User
		result2 error
	}{result1, result2}
}

func (fake *FakeUser) ByExternalID(arg1 context.Context, arg2 models.DBTX, arg3 string, arg4 ...models.UserSelectConfigOption) (*models.User, error) {
	fake.byExternalIDMutex.Lock()
	ret, specificReturn := fake.byExternalIDReturnsOnCall[len(fake.byExternalIDArgsForCall)]
	fake.byExternalIDArgsForCall = append(fake.byExternalIDArgsForCall, struct {
		arg1 context.Context
		arg2 models.DBTX
		arg3 string
		arg4 []models.UserSelectConfigOption
	}{arg1, arg2, arg3, arg4})
	stub := fake.ByExternalIDStub
	fakeReturns := fake.byExternalIDReturns
	fake.recordInvocation("ByExternalID", []interface{}{arg1, arg2, arg3, arg4})
	fake.byExternalIDMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeUser) ByExternalIDCallCount() int {
	fake.byExternalIDMutex.RLock()
	defer fake.byExternalIDMutex.RUnlock()
	return len(fake.byExternalIDArgsForCall)
}

func (fake *FakeUser) ByExternalIDCalls(stub func(context.Context, models.DBTX, string, ...models.UserSelectConfigOption) (*models.User, error)) {
	fake.byExternalIDMutex.Lock()
	defer fake.byExternalIDMutex.Unlock()
	fake.ByExternalIDStub = stub
}

func (fake *FakeUser) ByExternalIDArgsForCall(i int) (context.Context, models.DBTX, string, []models.UserSelectConfigOption) {
	fake.byExternalIDMutex.RLock()
	defer fake.byExternalIDMutex.RUnlock()
	argsForCall := fake.byExternalIDArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeUser) ByExternalIDReturns(result1 *models.User, result2 error) {
	fake.byExternalIDMutex.Lock()
	defer fake.byExternalIDMutex.Unlock()
	fake.ByExternalIDStub = nil
	fake.byExternalIDReturns = struct {
		result1 *models.User
		result2 error
	}{result1, result2}
}

func (fake *FakeUser) ByExternalIDReturnsOnCall(i int, result1 *models.User, result2 error) {
	fake.byExternalIDMutex.Lock()
	defer fake.byExternalIDMutex.Unlock()
	fake.ByExternalIDStub = nil
	if fake.byExternalIDReturnsOnCall == nil {
		fake.byExternalIDReturnsOnCall = make(map[int]struct {
			result1 *models.User
			result2 error
		})
	}
	fake.byExternalIDReturnsOnCall[i] = struct {
		result1 *models.User
		result2 error
	}{result1, result2}
}

func (fake *FakeUser) ByID(arg1 context.Context, arg2 models.DBTX, arg3 models.UserID, arg4 ...models.UserSelectConfigOption) (*models.User, error) {
	fake.byIDMutex.Lock()
	ret, specificReturn := fake.byIDReturnsOnCall[len(fake.byIDArgsForCall)]
	fake.byIDArgsForCall = append(fake.byIDArgsForCall, struct {
		arg1 context.Context
		arg2 models.DBTX
		arg3 models.UserID
		arg4 []models.UserSelectConfigOption
	}{arg1, arg2, arg3, arg4})
	stub := fake.ByIDStub
	fakeReturns := fake.byIDReturns
	fake.recordInvocation("ByID", []interface{}{arg1, arg2, arg3, arg4})
	fake.byIDMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeUser) ByIDCallCount() int {
	fake.byIDMutex.RLock()
	defer fake.byIDMutex.RUnlock()
	return len(fake.byIDArgsForCall)
}

func (fake *FakeUser) ByIDCalls(stub func(context.Context, models.DBTX, models.UserID, ...models.UserSelectConfigOption) (*models.User, error)) {
	fake.byIDMutex.Lock()
	defer fake.byIDMutex.Unlock()
	fake.ByIDStub = stub
}

func (fake *FakeUser) ByIDArgsForCall(i int) (context.Context, models.DBTX, models.UserID, []models.UserSelectConfigOption) {
	fake.byIDMutex.RLock()
	defer fake.byIDMutex.RUnlock()
	argsForCall := fake.byIDArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeUser) ByIDReturns(result1 *models.User, result2 error) {
	fake.byIDMutex.Lock()
	defer fake.byIDMutex.Unlock()
	fake.ByIDStub = nil
	fake.byIDReturns = struct {
		result1 *models.User
		result2 error
	}{result1, result2}
}

func (fake *FakeUser) ByIDReturnsOnCall(i int, result1 *models.User, result2 error) {
	fake.byIDMutex.Lock()
	defer fake.byIDMutex.Unlock()
	fake.ByIDStub = nil
	if fake.byIDReturnsOnCall == nil {
		fake.byIDReturnsOnCall = make(map[int]struct {
			result1 *models.User
			result2 error
		})
	}
	fake.byIDReturnsOnCall[i] = struct {
		result1 *models.User
		result2 error
	}{result1, result2}
}

func (fake *FakeUser) ByProject(arg1 context.Context, arg2 models.DBTX, arg3 models.ProjectID) ([]models.User, error) {
	fake.byProjectMutex.Lock()
	ret, specificReturn := fake.byProjectReturnsOnCall[len(fake.byProjectArgsForCall)]
	fake.byProjectArgsForCall = append(fake.byProjectArgsForCall, struct {
		arg1 context.Context
		arg2 models.DBTX
		arg3 models.ProjectID
	}{arg1, arg2, arg3})
	stub := fake.ByProjectStub
	fakeReturns := fake.byProjectReturns
	fake.recordInvocation("ByProject", []interface{}{arg1, arg2, arg3})
	fake.byProjectMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeUser) ByProjectCallCount() int {
	fake.byProjectMutex.RLock()
	defer fake.byProjectMutex.RUnlock()
	return len(fake.byProjectArgsForCall)
}

func (fake *FakeUser) ByProjectCalls(stub func(context.Context, models.DBTX, models.ProjectID) ([]models.User, error)) {
	fake.byProjectMutex.Lock()
	defer fake.byProjectMutex.Unlock()
	fake.ByProjectStub = stub
}

func (fake *FakeUser) ByProjectArgsForCall(i int) (context.Context, models.DBTX, models.ProjectID) {
	fake.byProjectMutex.RLock()
	defer fake.byProjectMutex.RUnlock()
	argsForCall := fake.byProjectArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeUser) ByProjectReturns(result1 []models.User, result2 error) {
	fake.byProjectMutex.Lock()
	defer fake.byProjectMutex.Unlock()
	fake.ByProjectStub = nil
	fake.byProjectReturns = struct {
		result1 []models.User
		result2 error
	}{result1, result2}
}

func (fake *FakeUser) ByProjectReturnsOnCall(i int, result1 []models.User, result2 error) {
	fake.byProjectMutex.Lock()
	defer fake.byProjectMutex.Unlock()
	fake.ByProjectStub = nil
	if fake.byProjectReturnsOnCall == nil {
		fake.byProjectReturnsOnCall = make(map[int]struct {
			result1 []models.User
			result2 error
		})
	}
	fake.byProjectReturnsOnCall[i] = struct {
		result1 []models.User
		result2 error
	}{result1, result2}
}

func (fake *FakeUser) ByTeam(arg1 context.Context, arg2 models.DBTX, arg3 models.TeamID) ([]models.User, error) {
	fake.byTeamMutex.Lock()
	ret, specificReturn := fake.byTeamReturnsOnCall[len(fake.byTeamArgsForCall)]
	fake.byTeamArgsForCall = append(fake.byTeamArgsForCall, struct {
		arg1 context.Context
		arg2 models.DBTX
		arg3 models.TeamID
	}{arg1, arg2, arg3})
	stub := fake.ByTeamStub
	fakeReturns := fake.byTeamReturns
	fake.recordInvocation("ByTeam", []interface{}{arg1, arg2, arg3})
	fake.byTeamMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeUser) ByTeamCallCount() int {
	fake.byTeamMutex.RLock()
	defer fake.byTeamMutex.RUnlock()
	return len(fake.byTeamArgsForCall)
}

func (fake *FakeUser) ByTeamCalls(stub func(context.Context, models.DBTX, models.TeamID) ([]models.User, error)) {
	fake.byTeamMutex.Lock()
	defer fake.byTeamMutex.Unlock()
	fake.ByTeamStub = stub
}

func (fake *FakeUser) ByTeamArgsForCall(i int) (context.Context, models.DBTX, models.TeamID) {
	fake.byTeamMutex.RLock()
	defer fake.byTeamMutex.RUnlock()
	argsForCall := fake.byTeamArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeUser) ByTeamReturns(result1 []models.User, result2 error) {
	fake.byTeamMutex.Lock()
	defer fake.byTeamMutex.Unlock()
	fake.ByTeamStub = nil
	fake.byTeamReturns = struct {
		result1 []models.User
		result2 error
	}{result1, result2}
}

func (fake *FakeUser) ByTeamReturnsOnCall(i int, result1 []models.User, result2 error) {
	fake.byTeamMutex.Lock()
	defer fake.byTeamMutex.Unlock()
	fake.ByTeamStub = nil
	if fake.byTeamReturnsOnCall == nil {
		fake.byTeamReturnsOnCall = make(map[int]struct {
			result1 []models.User
			result2 error
		})
	}
	fake.byTeamReturnsOnCall[i] = struct {
		result1 []models.User
		result2 error
	}{result1, result2}
}

func (fake *FakeUser) ByUsername(arg1 context.Context, arg2 models.DBTX, arg3 string, arg4 ...models.UserSelectConfigOption) (*models.User, error) {
	fake.byUsernameMutex.Lock()
	ret, specificReturn := fake.byUsernameReturnsOnCall[len(fake.byUsernameArgsForCall)]
	fake.byUsernameArgsForCall = append(fake.byUsernameArgsForCall, struct {
		arg1 context.Context
		arg2 models.DBTX
		arg3 string
		arg4 []models.UserSelectConfigOption
	}{arg1, arg2, arg3, arg4})
	stub := fake.ByUsernameStub
	fakeReturns := fake.byUsernameReturns
	fake.recordInvocation("ByUsername", []interface{}{arg1, arg2, arg3, arg4})
	fake.byUsernameMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeUser) ByUsernameCallCount() int {
	fake.byUsernameMutex.RLock()
	defer fake.byUsernameMutex.RUnlock()
	return len(fake.byUsernameArgsForCall)
}

func (fake *FakeUser) ByUsernameCalls(stub func(context.Context, models.DBTX, string, ...models.UserSelectConfigOption) (*models.User, error)) {
	fake.byUsernameMutex.Lock()
	defer fake.byUsernameMutex.Unlock()
	fake.ByUsernameStub = stub
}

func (fake *FakeUser) ByUsernameArgsForCall(i int) (context.Context, models.DBTX, string, []models.UserSelectConfigOption) {
	fake.byUsernameMutex.RLock()
	defer fake.byUsernameMutex.RUnlock()
	argsForCall := fake.byUsernameArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeUser) ByUsernameReturns(result1 *models.User, result2 error) {
	fake.byUsernameMutex.Lock()
	defer fake.byUsernameMutex.Unlock()
	fake.ByUsernameStub = nil
	fake.byUsernameReturns = struct {
		result1 *models.User
		result2 error
	}{result1, result2}
}

func (fake *FakeUser) ByUsernameReturnsOnCall(i int, result1 *models.User, result2 error) {
	fake.byUsernameMutex.Lock()
	defer fake.byUsernameMutex.Unlock()
	fake.ByUsernameStub = nil
	if fake.byUsernameReturnsOnCall == nil {
		fake.byUsernameReturnsOnCall = make(map[int]struct {
			result1 *models.User
			result2 error
		})
	}
	fake.byUsernameReturnsOnCall[i] = struct {
		result1 *models.User
		result2 error
	}{result1, result2}
}

func (fake *FakeUser) Create(arg1 context.Context, arg2 models.DBTX, arg3 *models.UserCreateParams) (*models.User, error) {
	fake.createMutex.Lock()
	ret, specificReturn := fake.createReturnsOnCall[len(fake.createArgsForCall)]
	fake.createArgsForCall = append(fake.createArgsForCall, struct {
		arg1 context.Context
		arg2 models.DBTX
		arg3 *models.UserCreateParams
	}{arg1, arg2, arg3})
	stub := fake.CreateStub
	fakeReturns := fake.createReturns
	fake.recordInvocation("Create", []interface{}{arg1, arg2, arg3})
	fake.createMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeUser) CreateCallCount() int {
	fake.createMutex.RLock()
	defer fake.createMutex.RUnlock()
	return len(fake.createArgsForCall)
}

func (fake *FakeUser) CreateCalls(stub func(context.Context, models.DBTX, *models.UserCreateParams) (*models.User, error)) {
	fake.createMutex.Lock()
	defer fake.createMutex.Unlock()
	fake.CreateStub = stub
}

func (fake *FakeUser) CreateArgsForCall(i int) (context.Context, models.DBTX, *models.UserCreateParams) {
	fake.createMutex.RLock()
	defer fake.createMutex.RUnlock()
	argsForCall := fake.createArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeUser) CreateReturns(result1 *models.User, result2 error) {
	fake.createMutex.Lock()
	defer fake.createMutex.Unlock()
	fake.CreateStub = nil
	fake.createReturns = struct {
		result1 *models.User
		result2 error
	}{result1, result2}
}

func (fake *FakeUser) CreateReturnsOnCall(i int, result1 *models.User, result2 error) {
	fake.createMutex.Lock()
	defer fake.createMutex.Unlock()
	fake.CreateStub = nil
	if fake.createReturnsOnCall == nil {
		fake.createReturnsOnCall = make(map[int]struct {
			result1 *models.User
			result2 error
		})
	}
	fake.createReturnsOnCall[i] = struct {
		result1 *models.User
		result2 error
	}{result1, result2}
}

func (fake *FakeUser) CreateAPIKey(arg1 context.Context, arg2 models.DBTX, arg3 *models.User) (*models.UserAPIKey, error) {
	fake.createAPIKeyMutex.Lock()
	ret, specificReturn := fake.createAPIKeyReturnsOnCall[len(fake.createAPIKeyArgsForCall)]
	fake.createAPIKeyArgsForCall = append(fake.createAPIKeyArgsForCall, struct {
		arg1 context.Context
		arg2 models.DBTX
		arg3 *models.User
	}{arg1, arg2, arg3})
	stub := fake.CreateAPIKeyStub
	fakeReturns := fake.createAPIKeyReturns
	fake.recordInvocation("CreateAPIKey", []interface{}{arg1, arg2, arg3})
	fake.createAPIKeyMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeUser) CreateAPIKeyCallCount() int {
	fake.createAPIKeyMutex.RLock()
	defer fake.createAPIKeyMutex.RUnlock()
	return len(fake.createAPIKeyArgsForCall)
}

func (fake *FakeUser) CreateAPIKeyCalls(stub func(context.Context, models.DBTX, *models.User) (*models.UserAPIKey, error)) {
	fake.createAPIKeyMutex.Lock()
	defer fake.createAPIKeyMutex.Unlock()
	fake.CreateAPIKeyStub = stub
}

func (fake *FakeUser) CreateAPIKeyArgsForCall(i int) (context.Context, models.DBTX, *models.User) {
	fake.createAPIKeyMutex.RLock()
	defer fake.createAPIKeyMutex.RUnlock()
	argsForCall := fake.createAPIKeyArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeUser) CreateAPIKeyReturns(result1 *models.UserAPIKey, result2 error) {
	fake.createAPIKeyMutex.Lock()
	defer fake.createAPIKeyMutex.Unlock()
	fake.CreateAPIKeyStub = nil
	fake.createAPIKeyReturns = struct {
		result1 *models.UserAPIKey
		result2 error
	}{result1, result2}
}

func (fake *FakeUser) CreateAPIKeyReturnsOnCall(i int, result1 *models.UserAPIKey, result2 error) {
	fake.createAPIKeyMutex.Lock()
	defer fake.createAPIKeyMutex.Unlock()
	fake.CreateAPIKeyStub = nil
	if fake.createAPIKeyReturnsOnCall == nil {
		fake.createAPIKeyReturnsOnCall = make(map[int]struct {
			result1 *models.UserAPIKey
			result2 error
		})
	}
	fake.createAPIKeyReturnsOnCall[i] = struct {
		result1 *models.UserAPIKey
		result2 error
	}{result1, result2}
}

func (fake *FakeUser) Delete(arg1 context.Context, arg2 models.DBTX, arg3 models.UserID) (*models.User, error) {
	fake.deleteMutex.Lock()
	ret, specificReturn := fake.deleteReturnsOnCall[len(fake.deleteArgsForCall)]
	fake.deleteArgsForCall = append(fake.deleteArgsForCall, struct {
		arg1 context.Context
		arg2 models.DBTX
		arg3 models.UserID
	}{arg1, arg2, arg3})
	stub := fake.DeleteStub
	fakeReturns := fake.deleteReturns
	fake.recordInvocation("Delete", []interface{}{arg1, arg2, arg3})
	fake.deleteMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeUser) DeleteCallCount() int {
	fake.deleteMutex.RLock()
	defer fake.deleteMutex.RUnlock()
	return len(fake.deleteArgsForCall)
}

func (fake *FakeUser) DeleteCalls(stub func(context.Context, models.DBTX, models.UserID) (*models.User, error)) {
	fake.deleteMutex.Lock()
	defer fake.deleteMutex.Unlock()
	fake.DeleteStub = stub
}

func (fake *FakeUser) DeleteArgsForCall(i int) (context.Context, models.DBTX, models.UserID) {
	fake.deleteMutex.RLock()
	defer fake.deleteMutex.RUnlock()
	argsForCall := fake.deleteArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeUser) DeleteReturns(result1 *models.User, result2 error) {
	fake.deleteMutex.Lock()
	defer fake.deleteMutex.Unlock()
	fake.DeleteStub = nil
	fake.deleteReturns = struct {
		result1 *models.User
		result2 error
	}{result1, result2}
}

func (fake *FakeUser) DeleteReturnsOnCall(i int, result1 *models.User, result2 error) {
	fake.deleteMutex.Lock()
	defer fake.deleteMutex.Unlock()
	fake.DeleteStub = nil
	if fake.deleteReturnsOnCall == nil {
		fake.deleteReturnsOnCall = make(map[int]struct {
			result1 *models.User
			result2 error
		})
	}
	fake.deleteReturnsOnCall[i] = struct {
		result1 *models.User
		result2 error
	}{result1, result2}
}

func (fake *FakeUser) DeleteAPIKey(arg1 context.Context, arg2 models.DBTX, arg3 string) (*models.UserAPIKey, error) {
	fake.deleteAPIKeyMutex.Lock()
	ret, specificReturn := fake.deleteAPIKeyReturnsOnCall[len(fake.deleteAPIKeyArgsForCall)]
	fake.deleteAPIKeyArgsForCall = append(fake.deleteAPIKeyArgsForCall, struct {
		arg1 context.Context
		arg2 models.DBTX
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.DeleteAPIKeyStub
	fakeReturns := fake.deleteAPIKeyReturns
	fake.recordInvocation("DeleteAPIKey", []interface{}{arg1, arg2, arg3})
	fake.deleteAPIKeyMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeUser) DeleteAPIKeyCallCount() int {
	fake.deleteAPIKeyMutex.RLock()
	defer fake.deleteAPIKeyMutex.RUnlock()
	return len(fake.deleteAPIKeyArgsForCall)
}

func (fake *FakeUser) DeleteAPIKeyCalls(stub func(context.Context, models.DBTX, string) (*models.UserAPIKey, error)) {
	fake.deleteAPIKeyMutex.Lock()
	defer fake.deleteAPIKeyMutex.Unlock()
	fake.DeleteAPIKeyStub = stub
}

func (fake *FakeUser) DeleteAPIKeyArgsForCall(i int) (context.Context, models.DBTX, string) {
	fake.deleteAPIKeyMutex.RLock()
	defer fake.deleteAPIKeyMutex.RUnlock()
	argsForCall := fake.deleteAPIKeyArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeUser) DeleteAPIKeyReturns(result1 *models.UserAPIKey, result2 error) {
	fake.deleteAPIKeyMutex.Lock()
	defer fake.deleteAPIKeyMutex.Unlock()
	fake.DeleteAPIKeyStub = nil
	fake.deleteAPIKeyReturns = struct {
		result1 *models.UserAPIKey
		result2 error
	}{result1, result2}
}

func (fake *FakeUser) DeleteAPIKeyReturnsOnCall(i int, result1 *models.UserAPIKey, result2 error) {
	fake.deleteAPIKeyMutex.Lock()
	defer fake.deleteAPIKeyMutex.Unlock()
	fake.DeleteAPIKeyStub = nil
	if fake.deleteAPIKeyReturnsOnCall == nil {
		fake.deleteAPIKeyReturnsOnCall = make(map[int]struct {
			result1 *models.UserAPIKey
			result2 error
		})
	}
	fake.deleteAPIKeyReturnsOnCall[i] = struct {
		result1 *models.UserAPIKey
		result2 error
	}{result1, result2}
}

func (fake *FakeUser) Paginated(arg1 context.Context, arg2 models.DBTX, arg3 repos.GetPaginatedUsersParams) ([]models.User, error) {
	fake.paginatedMutex.Lock()
	ret, specificReturn := fake.paginatedReturnsOnCall[len(fake.paginatedArgsForCall)]
	fake.paginatedArgsForCall = append(fake.paginatedArgsForCall, struct {
		arg1 context.Context
		arg2 models.DBTX
		arg3 repos.GetPaginatedUsersParams
	}{arg1, arg2, arg3})
	stub := fake.PaginatedStub
	fakeReturns := fake.paginatedReturns
	fake.recordInvocation("Paginated", []interface{}{arg1, arg2, arg3})
	fake.paginatedMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeUser) PaginatedCallCount() int {
	fake.paginatedMutex.RLock()
	defer fake.paginatedMutex.RUnlock()
	return len(fake.paginatedArgsForCall)
}

func (fake *FakeUser) PaginatedCalls(stub func(context.Context, models.DBTX, repos.GetPaginatedUsersParams) ([]models.User, error)) {
	fake.paginatedMutex.Lock()
	defer fake.paginatedMutex.Unlock()
	fake.PaginatedStub = stub
}

func (fake *FakeUser) PaginatedArgsForCall(i int) (context.Context, models.DBTX, repos.GetPaginatedUsersParams) {
	fake.paginatedMutex.RLock()
	defer fake.paginatedMutex.RUnlock()
	argsForCall := fake.paginatedArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeUser) PaginatedReturns(result1 []models.User, result2 error) {
	fake.paginatedMutex.Lock()
	defer fake.paginatedMutex.Unlock()
	fake.PaginatedStub = nil
	fake.paginatedReturns = struct {
		result1 []models.User
		result2 error
	}{result1, result2}
}

func (fake *FakeUser) PaginatedReturnsOnCall(i int, result1 []models.User, result2 error) {
	fake.paginatedMutex.Lock()
	defer fake.paginatedMutex.Unlock()
	fake.PaginatedStub = nil
	if fake.paginatedReturnsOnCall == nil {
		fake.paginatedReturnsOnCall = make(map[int]struct {
			result1 []models.User
			result2 error
		})
	}
	fake.paginatedReturnsOnCall[i] = struct {
		result1 []models.User
		result2 error
	}{result1, result2}
}

func (fake *FakeUser) Update(arg1 context.Context, arg2 models.DBTX, arg3 models.UserID, arg4 *models.UserUpdateParams) (*models.User, error) {
	fake.updateMutex.Lock()
	ret, specificReturn := fake.updateReturnsOnCall[len(fake.updateArgsForCall)]
	fake.updateArgsForCall = append(fake.updateArgsForCall, struct {
		arg1 context.Context
		arg2 models.DBTX
		arg3 models.UserID
		arg4 *models.UserUpdateParams
	}{arg1, arg2, arg3, arg4})
	stub := fake.UpdateStub
	fakeReturns := fake.updateReturns
	fake.recordInvocation("Update", []interface{}{arg1, arg2, arg3, arg4})
	fake.updateMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeUser) UpdateCallCount() int {
	fake.updateMutex.RLock()
	defer fake.updateMutex.RUnlock()
	return len(fake.updateArgsForCall)
}

func (fake *FakeUser) UpdateCalls(stub func(context.Context, models.DBTX, models.UserID, *models.UserUpdateParams) (*models.User, error)) {
	fake.updateMutex.Lock()
	defer fake.updateMutex.Unlock()
	fake.UpdateStub = stub
}

func (fake *FakeUser) UpdateArgsForCall(i int) (context.Context, models.DBTX, models.UserID, *models.UserUpdateParams) {
	fake.updateMutex.RLock()
	defer fake.updateMutex.RUnlock()
	argsForCall := fake.updateArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeUser) UpdateReturns(result1 *models.User, result2 error) {
	fake.updateMutex.Lock()
	defer fake.updateMutex.Unlock()
	fake.UpdateStub = nil
	fake.updateReturns = struct {
		result1 *models.User
		result2 error
	}{result1, result2}
}

func (fake *FakeUser) UpdateReturnsOnCall(i int, result1 *models.User, result2 error) {
	fake.updateMutex.Lock()
	defer fake.updateMutex.Unlock()
	fake.UpdateStub = nil
	if fake.updateReturnsOnCall == nil {
		fake.updateReturnsOnCall = make(map[int]struct {
			result1 *models.User
			result2 error
		})
	}
	fake.updateReturnsOnCall[i] = struct {
		result1 *models.User
		result2 error
	}{result1, result2}
}

func (fake *FakeUser) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeUser) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ repos.User = new(FakeUser)
