// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.16.0
// source: users.sql

package db

import (
	"context"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgtype"
)

const GetUser = `-- name: GetUser :one
select
  username
  , email
  , role_rank
  , created_at
  , updated_at
  , user_id
  -- case when @get_db_data::boolean then
  --   (user_id)
  -- end as user_id, -- TODO sqlc.yaml overrides sql.NullInt64
from
  users
where (email = LOWER($1)::text
  or $1::text is null)
and (username = $2::text
  or $2::text is null)
and (user_id = $3::uuid
  or $3::uuid is null)
limit 1
`

type GetUserParams struct {
	Email    *string    `db:"email" json:"email"`
	Username *string    `db:"username" json:"username"`
	UserID   *uuid.UUID `db:"user_id" json:"user_id"`
}

type GetUserRow struct {
	Username  string    `db:"username" json:"username"`
	Email     string    `db:"email" json:"email"`
	RoleRank  int16     `db:"role_rank" json:"role_rank"`
	CreatedAt time.Time `db:"created_at" json:"created_at"`
	UpdatedAt time.Time `db:"updated_at" json:"updated_at"`
	UserID    uuid.UUID `db:"user_id" json:"user_id"`
}

func (q *Queries) GetUser(ctx context.Context, db DBTX, arg GetUserParams) (GetUserRow, error) {
	row := db.QueryRow(ctx, GetUser, arg.Email, arg.Username, arg.UserID)
	var i GetUserRow
	err := row.Scan(
		&i.Username,
		&i.Email,
		&i.RoleRank,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.UserID,
	)
	return i, err
}

const GetUsersWithJoins = `-- name: GetUsersWithJoins :many
select
  (
    case when $1::boolean = true then
      joined_work_items.work_items
    end)::jsonb as work_items -- if M2M
  , (
    case when $2::boolean = true then
      joined_teams.teams
    end)::jsonb as teams -- if M2M
  , (
    case when $3::boolean = true then
      ROW_TO_JSON(user_api_keys.*)
    end)::jsonb as user_api_key -- if O2O
  , (
    case when $4::boolean = true then
      joined_time_entries.time_entries
    end)::jsonb as time_entries -- if O2M
  , users.user_id, users.username, users.email, users.first_name, users.last_name, users.full_name, users.external_id, users.scopes, users.role_rank, users.created_at, users.updated_at, users.deleted_at
from
  users
  ------------------------------
  left join (
    select
      member as work_items_user_id
      , JSON_AGG(work_items.*) as work_items
    from
      work_item_member uo
      join work_items using (work_item_id)
    where
      member in (
        select
          member
        from
          work_item_member
        where
          work_item_id = any (
            select
              work_item_id
            from
              work_items))
        group by
          member) joined_work_items on joined_work_items.work_items_user_id = users.user_id
  ------------------------------
  left join (
    select
      user_id as teams_user_id
      , JSON_AGG(teams.*) as teams
    from
      user_team uo
      join teams using (team_id)
    where
      user_id in (
        select
          user_id
        from
          user_team
        where
          team_id = any (
            select
              team_id
            from
              teams))
        group by
          user_id) joined_teams on joined_teams.teams_user_id = users.user_id
  ------------------------------
  -- this below would be O2M (we return an array agg)
  -- same as with work_item comments when selecting work_items
  -- since work_item_id is not unique in work_item_comments
  -- we assume cardinality:O2M. to distinguish O2M and M2M, cardinality:M2M comment, else O2M is assumed
  left join (
    select
      user_id
      , JSON_AGG(time_entries.*) as time_entries
    from
      time_entries
    group by
      user_id) joined_time_entries using (user_id)
------------------------------
-- this below would be O2O
  left join user_api_keys using (user_id)
`

type GetUsersWithJoinsParams struct {
	JoinWorkItems   bool `db:"join_work_items" json:"join_work_items"`
	JoinTeams       bool `db:"join_teams" json:"join_teams"`
	JoinUserApiKeys bool `db:"join_user_api_keys" json:"join_user_api_keys"`
	JoinTimeEntries bool `db:"join_time_entries" json:"join_time_entries"`
}

type GetUsersWithJoinsRow struct {
	WorkItems   pgtype.JSONB `db:"work_items" json:"work_items"`
	Teams       pgtype.JSONB `db:"teams" json:"teams"`
	UserApiKey  pgtype.JSONB `db:"user_api_key" json:"user_api_key"`
	TimeEntries pgtype.JSONB `db:"time_entries" json:"time_entries"`
	UserID      uuid.UUID    `db:"user_id" json:"user_id"`
	Username    string       `db:"username" json:"username"`
	Email       string       `db:"email" json:"email"`
	FirstName   *string      `db:"first_name" json:"first_name"`
	LastName    *string      `db:"last_name" json:"last_name"`
	FullName    *string      `db:"full_name" json:"full_name"`
	ExternalID  *string      `db:"external_id" json:"external_id"`
	Scopes      []string     `db:"scopes" json:"scopes"`
	RoleRank    int16        `db:"role_rank" json:"role_rank"`
	CreatedAt   time.Time    `db:"created_at" json:"created_at"`
	UpdatedAt   time.Time    `db:"updated_at" json:"updated_at"`
	DeletedAt   *time.Time   `db:"deleted_at" json:"deleted_at"`
}

func (q *Queries) GetUsersWithJoins(ctx context.Context, db DBTX, arg GetUsersWithJoinsParams) ([]GetUsersWithJoinsRow, error) {
	rows, err := db.Query(ctx, GetUsersWithJoins,
		arg.JoinWorkItems,
		arg.JoinTeams,
		arg.JoinUserApiKeys,
		arg.JoinTimeEntries,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetUsersWithJoinsRow{}
	for rows.Next() {
		var i GetUsersWithJoinsRow
		if err := rows.Scan(
			&i.WorkItems,
			&i.Teams,
			&i.UserApiKey,
			&i.TimeEntries,
			&i.UserID,
			&i.Username,
			&i.Email,
			&i.FirstName,
			&i.LastName,
			&i.FullName,
			&i.ExternalID,
			&i.Scopes,
			&i.RoleRank,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListAllUsers = `-- name: ListAllUsers :many
select
  user_id
  , username
  , email
  , role_rank
  , created_at
  , updated_at
from
  users
`

type ListAllUsersRow struct {
	UserID    uuid.UUID `db:"user_id" json:"user_id"`
	Username  string    `db:"username" json:"username"`
	Email     string    `db:"email" json:"email"`
	RoleRank  int16     `db:"role_rank" json:"role_rank"`
	CreatedAt time.Time `db:"created_at" json:"created_at"`
	UpdatedAt time.Time `db:"updated_at" json:"updated_at"`
}

func (q *Queries) ListAllUsers(ctx context.Context, db DBTX) ([]ListAllUsersRow, error) {
	rows, err := db.Query(ctx, ListAllUsers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListAllUsersRow{}
	for rows.Next() {
		var i ListAllUsersRow
		if err := rows.Scan(
			&i.UserID,
			&i.Username,
			&i.Email,
			&i.RoleRank,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const RegisterNewUser = `-- name: RegisterNewUser :one
insert into users (username, email, role_rank)
  values ($1, $2, $3)
returning
  user_id, username, email, role_rank, created_at, updated_at
`

type RegisterNewUserParams struct {
	Username string `db:"username" json:"username"`
	Email    string `db:"email" json:"email"`
	RoleRank int16  `db:"role_rank" json:"role_rank"`
}

type RegisterNewUserRow struct {
	UserID    uuid.UUID `db:"user_id" json:"user_id"`
	Username  string    `db:"username" json:"username"`
	Email     string    `db:"email" json:"email"`
	RoleRank  int16     `db:"role_rank" json:"role_rank"`
	CreatedAt time.Time `db:"created_at" json:"created_at"`
	UpdatedAt time.Time `db:"updated_at" json:"updated_at"`
}

func (q *Queries) RegisterNewUser(ctx context.Context, db DBTX, arg RegisterNewUserParams) (RegisterNewUserRow, error) {
	row := db.QueryRow(ctx, RegisterNewUser, arg.Username, arg.Email, arg.RoleRank)
	var i RegisterNewUserRow
	err := row.Scan(
		&i.UserID,
		&i.Username,
		&i.Email,
		&i.RoleRank,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const UpdateUserById = `-- name: UpdateUserById :exec
update
  users
set
  username = COALESCE($1 , username)
  , email = COALESCE(LOWER($2) , email)
where
  user_id = $3
`

type UpdateUserByIdParams struct {
	Username *string   `db:"username" json:"username"`
	Email    *string   `db:"email" json:"email"`
	UserID   uuid.UUID `db:"user_id" json:"user_id"`
}

func (q *Queries) UpdateUserById(ctx context.Context, db DBTX, arg UpdateUserByIdParams) error {
	_, err := db.Exec(ctx, UpdateUserById, arg.Username, arg.Email, arg.UserID)
	return err
}
