#!/bin/bash
# shellcheck disable=1091,2155,2068,2086,2031,2048,2178,2120
#
#
# Main s̶c̶r̶i̶p̶t program to manage the entire project stack.
#
#
source ".project.xfunctions.sh"

export PROC=$$

export POSTGRES_TRACE=${POSTGRES_TRACE:-false}
export GIN_MODE=${GIN_MODE:-release}

starting_cwd=$(pwd)

# log for any function output.
xlog() {
  local fname="${FUNCNAME[1]#*.}"
  local color="$BLUE"
  local max_len=$MAX_FNAME_LOG_LEN

  [[ "$CMD" = "$fname" ]] && cat && return

  if [[ "${FUNCNAME[1]%%.*}" != "x" ]]; then
    fname="${FUNCNAME[1]}" # show non-x funcs
    color="$MAGENTA"
  fi

  if [[ "${FUNCNAME[1]}" =~ ^.*(check\.bin|install\.bin).* ]]; then
    max_len=100
  fi

  if [[ ${#fname} -gt $max_len ]]; then
    fname="${fname:0:$max_len}…"
  fi

  local _=$(printf "%*s |\n" $((max_len + 1)) "$fname")
  sed -ue "s/^/${color}$fname >${OFF} /"
}

# log stderr for any function output.
# sed is buffering by default (without -u) so streams dont preserve order
# > >(one) 2> >(two) are background processes so it will break our parallel code.
xerr() {
  local fname="${FUNCNAME[1]#*.}"
  local max_len=$MAX_FNAME_LOG_LEN

  [[ "$CMD" = "$fname" ]] && cat && return
  if [[ ${#fname} -gt $max_len ]]; then
    fname="${fname:0:$max_len}…"
  fi

  local _=$(printf "%*s |\n" $((max_len + 1)) "$fname")
  sed -ue "s/^/${RED}$fname >${OFF} /" >&2
}

kill_descendants() {
  # air and vite spawn processes as well, need to kill those (whose parent is pid), kill $pid will not kill children. pkill -P would also work
  kill $pids || true
  kill "$(list_descendants $pids)" || true
  pids=""
}

######################## ENTRYPOINT ########################

ensure_pwd_is_top_level

set -Eeo pipefail
set -o errtrace

X_ENV="dev"

# --------------------- completion and delegation --------------------
#      `complete -o nospace -C foo foo` > `source <(foo bloated_completion)`

while IFS= read -r line; do
  [[ $line =~ ^declare\ -f\ x\. ]] || continue
  COMMANDS+=("${line##declare -f x.}")
done < <(declare -F)
# sort the array. Mimic file input to sort
mapfile -t COMMANDS < \
  <(LC_COLLATE=C sort < <(printf "%s\n" "${COMMANDS[@]}"))

MAX_XFN_LEN=0 # for logging purposes
for c in "${COMMANDS[@]}"; do
  len=${#c}
  ((len > MAX_XFN_LEN)) && MAX_XFN_LEN=$((len - 1)) # remove "x." but account for extra last space appended.
done

complete_commands # exits script early if in completion mode

parse_args

######################## INIT ########################

# applicable to any command
ensure_envvars_set ".env.template" ".env.${X_ENV}"

# export to all subsequent commands or scripts
set -a
# TODO: wrapper around source that for each var in file
# checks if its defined, e.g. P4="" test -v P4
# and if so saves to a global current_env assoc array
# that is shared for all calls of this wrapper func
# shellcheck source=SCRIPTDIR/../.env.dev
source ".env.$X_ENV"
set +a

trap 'show_tracebacks' ERR
trap killgroup EXIT HUP INT TERM
trap errtrap SIGUSR1
trap 'exit-cleanup $LINENO' EXIT HUP INT TERM # EXIT (0) executed on exit from the shell

exit-cleanup() {
  if [[ $restore_cache = 1 && -z $X_NO_CACHE ]]; then
    xsetup.backup-gen.restore
  fi

  rm -f backup-gen-stash-dummy.txt
  git checkout "$CURRENT_BRANCH" &>/dev/null || true
  git branch -D "$gen_backup_branch" &>/dev/null || true
  cd "$starting_cwd" || true
}

killgroup() {
  printf "\nKilling spawned processes...\n\n"
  # kill $(jobs -p) 2>/dev/null # doesn't really kill all children, just process group leaders
  kill_descendants 2>/dev/null || true
  pgrep -P $PROC | xargs kill || true
  exit 1
}

errtrap() {
  printf "\nExiting due to propagated error...\n"
  killgroup
}

source ".envrc"

pids=""

################ handle executing x functions ################

if [[ -n "$1" ]]; then
  shift
  for c in "${COMMANDS[@]}"; do
    declare cmd=$(command -v "x.$c")
    if [[ $c == "$CMD" && -n "$cmd" ]]; then
      "x.$CMD" "$@"
      if [[ -n $X_IGNORE_BUILD_ERRORS ]]; then
        echo "${YELLOW}[WARNING] A rerun without ignoring build errors is required" && continue
      fi
      exit $?
    fi
  done
fi

# default to show usage if its a noop
usage
