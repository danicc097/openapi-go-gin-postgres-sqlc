#!/bin/bash
# shellcheck disable=SC1091,SC2155

source "${BASH_SOURCE%/*}/.helpers.sh"

set -e

ensure_pwd_is_top_level

export GIT_USER_ID=danicc097
export GIT_REPO_ID=openapi-go-gin-postgres-sqlc
export GO_POST_PROCESS_FILE="/usr/bin/env gofmt -w -s"
export GENVERS=6.0.1

SPEC="openapi.yaml"
GEN_OUT_DIR="internal"
PWD="$(pwd)"
ENV_FILE=".env"

x.bootstrap() {
  x.install-tools
  x.fetch-openapi-generator-jar
  x.download-swagger-ui
}

x.install-go-tools() {
  set -o errexit -eo pipefail

  go install -tags 'postgres' github.com/golang-migrate/migrate/v4/cmd/migrate@v4.15.2
  go install github.com/kyleconroy/sqlc/cmd/sqlc@v1.15.0
  go install github.com/golangci/golangci-lint/cmd/golangci-lint@v1.47.2
  go install github.com/joho/godotenv/cmd/godotenv@latest
  go install github.com/cosmtrek/air@latest

  GO111MODULE=off go get -u github.com/maxbrunsfeld/counterfeiter
}

x.fetch-openapi-generator-jar() {
  local url="https://repo1.maven.org/maven2/org/openapitools/openapi-generator-cli/$GENVERS/openapi-generator-cli-$GENVERS.jar"
  echo "$url > openapi-generator-cli.jar"
  curl -L "$url" -o openapi-generator-cli.jar
}

x.validate() {
  java -jar openapi-generator-cli.jar validate -i "$SPEC"
}

x.generate-api() {
  echo $GIT_USER_ID $GIT_REPO_ID
  echo Generating API from "$SPEC"
  rm -rf "$GEN_OUT_DIR/gen"
  java -jar openapi-generator-cli.jar generate \
    -g go-gin-server \
    -i "$SPEC" \
    -o "$GEN_OUT_DIR" \
    --additional-properties=packageName=openapi,apiPath=gen,hideGenerationTimestamp=true \
    -t internal/go-gin-server-templates \
    --enable-post-process-file \
    >/dev/null
  mkdir -p "$GEN_OUT_DIR"/gen/models
  mv "$GEN_OUT_DIR"/gen/model_*.go "$GEN_OUT_DIR"/gen/models
  # not needed with locally generated code
  # local name="$(id -un)"
  # sudo chown -R "$name:$name" "$GEN_OUT_DIR"
  cp internal/static/swagger-override/swagger-initializer.js internal/static/swagger-ui/
  cp "$SPEC" "$PWD"/internal/static/swagger-ui
  go build -o post-generate-api "$PWD"/cmd/post-generate-api/main.go
  ./post-generate-api
  find "$GEN_OUT_DIR/gen/" -name "api_*.go" -type f -delete
  rm -rf "$GEN_OUT_DIR/api"
}

x.generate-sqlc() {
  bin/scripts/sql-format.sh
  cd internal/postgresql && sqlc generate && cd - || exit
}

x.generate() {
  go generate ./...
  x.generate-api
  x.generate-sqlc
}

x.test() {
  x.generate
  create_test_database
  godotenv -f "$ENV_FILE" go test ./... "$@"
}

x.build() {
  x.test ""
  go build -o openapi-go-gin-postgres-sqlc "$PWD"/cmd/rest-server
}

x.run() {
  docker-compose up -d
  x.build
  ./openapi-go-gin-postgres-sqlc -env="$ENV_FILE"
}

x.run-hot-reload() {
  docker-compose up -d
  x.test
  air \
    --build.cmd "go build -o ./air-main ./cmd/rest-server/" \
    --build.bin "./air-main -env=$ENV_FILE"
}

x.download-swagger-ui() {
  name="$(curl --silent "https://api.github.com/repos/swagger-api/swagger-ui/releases/latest" | jq -r ".. .tag_name? // empty")"
  curl -fsSL "github.com/swagger-api/swagger-ui/archive/refs/tags/$name.tar.gz" -o swagger-ui.tar.gz
  tar xf swagger-ui.tar.gz swagger-ui-"${name#*v}"/dist --one-top-level=swagger-ui --strip-components=2
  rm swagger-ui.tar.gz
  mkdir -p internal/static/swagger-ui
  mv swagger-ui/* internal/static/swagger-ui/
  rm -r swagger-ui
}

x.migrate() {
  source "$ENV_FILE"
  migrate \
    -path db/migrations/ \
    -database "postgres://$POSTGRES_USER:$POSTGRES_PASSWORD@$POSTGRES_SERVER:$DB_PORT/$POSTGRES_DB?sslmode=disable" \
    "$@"
}

x.create-migration() {
  x.migrate create -ext sql -dir db/migrations/ "$@"
}

create_test_database() {
  declare -A env
  get_envvars env .env

  local postgres_test_db="${env[POSTGRES_DB]}_test"

  drop_db "$postgres_test_db" .env

  echo "${BLUE}${BOLD}Stopping any running processes for database $postgres_test_db.${OFF}"
  docker exec -t postgres_db_"${env[PROJECT_PREFIX]}"_"${env[APP_ENV]}" \
    psql --no-psqlrc \
    -U "${env[POSTGRES_USER]}" \
    -d "${env[POSTGRES_DB]}" \
    -c "select pg_terminate_backend(pid) \
        from pg_stat_activity \
        where datname='$postgres_test_db'"
}

# --------------------- completion and delegation --------------------
#      `complete -C foo foo` > `source <(foo bloated_completion)`

while IFS= read -r line; do
  [[ $line =~ ^declare\ -f\ x\. ]] || continue
  COMMANDS+=("${line##declare -f x.}")
done < <(declare -F)
mapfile -t COMMANDS < \
  <(LC_COLLATE=C sort < <(printf "%s\n" "${COMMANDS[@]}"))

if [[ -n $COMP_LINE ]]; then
  line=${COMP_LINE#* }
  for c in "${COMMANDS[@]}"; do
    [[ ${c:0:${#line}} == "${line,,}" ]] && echo "$c"
  done
  exit
fi

for c in "${COMMANDS[@]}"; do
  if [[ $c == "$EXE" ]]; then
    "x.$EXE" "$@"
    exit $?
  fi
done

if [[ -n "$1" ]]; then
  declare CMD="$1"
  shift
  for c in "${COMMANDS[@]}"; do
    declare cmd=$(command -v "x.$c")
    if [[ $c == "$CMD" && -n "$cmd" ]]; then
      "x.$CMD" "$@"
      exit $?
    fi
  done
fi
