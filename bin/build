#!/bin/bash
# shellcheck disable=1091,2155,2068,2086

source "${BASH_SOURCE%/*}/.helpers.sh"
source "${BASH_SOURCE%/*}/scripts/deps-check.sh"

set -e

ensure_pwd_is_top_level

export GIT_USER_ID=danicc097
export GIT_REPO_ID=openapi-go-gin-postgres-sqlc
export GO_POST_PROCESS_FILE="/usr/bin/env gofmt -w -s"
export GENVERS=6.0.1

SPEC="openapi.yaml"
GEN_OUT_DIR="internal"
TEMPLATE_DIR="internal/go-gin-server-templates"
PWD="$(pwd)"
ENV_FILE=".env"
BIN_DIR=$(dirname "$0")
PG_REPO="internal/repos/postgresql"

# Check build dependencies are met.
x.check-build-deps() {
  local -i fails
  check.column || { ((fails++)) && true; }
  check.bash || { ((fails++)) && true; }
  check.go || { ((fails++)) && true; }
  check.java || { ((fails++)) && true; }
  check.curl || { ((fails++)) && true; }
  check.docker || { ((fails++)) && true; }
  check.docker-compose || { ((fails++)) && true; }
  check.direnv || { ((fails++)) && true; }
  check.yq || { ((fails++)) && true; }

  { ((fails == 0)) && echo "${GREEN}🎉 All build dependencies met${OFF}"; }
  { ((fails != 0)) && echo "${RED}❌ Missing dependencies.${OFF}"; } || exit 1
}

# Check dependencies and fetch required tools.
x.bootstrap() {
  x.check-build-deps
  x.install-tools
  x.fetch.openapi-generator
  x.fetch.swagger-ui
}

# Install go libraries as runnable programs.
x.install-tools() {
  set -o errexit -eo pipefail

  go install -tags 'postgres' github.com/golang-migrate/migrate/v4/cmd/migrate@v4.15.2
  go install github.com/kyleconroy/sqlc/cmd/sqlc@v1.15.0
  go install github.com/golangci/golangci-lint/cmd/golangci-lint@v1.47.2
  go install github.com/joho/godotenv/cmd/godotenv@latest
  go install github.com/danicc097/air@latest
  go install github.com/xo/xo@latest
  go install github.com/tufin/oasdiff@latest

  GO111MODULE=off go get -u github.com/maxbrunsfeld/counterfeiter
}

# Fetch openapi-generator jar file.
x.fetch.openapi-generator() {
  local url="https://repo1.maven.org/maven2/org/openapitools/openapi-generator-cli/$GENVERS/openapi-generator-cli-$GENVERS.jar"
  echo "$url > openapi-generator-cli.jar"
  curl -L "$url" -o openapi-generator-cli.jar
}

# Fetch latest swagger ui bundle.
x.fetch.swagger-ui() {
  name="$(curl --silent "https://api.github.com/repos/swagger-api/swagger-ui/releases/latest" | jq -r ".. .tag_name? // empty")"
  curl -fsSL "github.com/swagger-api/swagger-ui/archive/refs/tags/$name.tar.gz" -o swagger-ui.tar.gz
  tar xf swagger-ui.tar.gz swagger-ui-"${name#*v}"/dist --one-top-level=swagger-ui --strip-components=2
  rm swagger-ui.tar.gz
  mkdir -p internal/static/swagger-ui
  mv swagger-ui/* internal/static/swagger-ui/
  rm -r swagger-ui
}

# Run openapi generator for testdata.
# jar won't output properly if absolute paths are passed from subdir.
x.generate.tests-api() {
  local testdata="$BIN_DIR/../tests/testdata/postgen/openapi_generator"
  local test_dirs=$(find "$testdata" -maxdepth 1 -mindepth 1 -type d -exec basename {} \;)

  cache=".generate-tests-api.cache"
  for test_dir in $test_dirs; do
    x.generate.api \
      "$cache" \
      "$test_dir" \
      "$testdata/$test_dir/openapi.yaml" \
      "$testdata/$test_dir/internal" \
      "$BIN_DIR/../internal/go-gin-server-templates"
  done
}

# Run openapi generator for the internal package.
x.generate.api() {
  cache="$1"
  prefix="$2"
  spec="$3"
  gen_out_dir="$4"
  template_dir="$5"

  invalid_cache=false
  mkdir -p "$cache"

  if ! md5sum -c "$cache/$prefix-go-gin-server-templates.md5" >/dev/null; then
    invalid_cache=true
    md5sum "$BIN_DIR"/../internal/go-gin-server-templates/* >"$cache/$prefix-go-gin-server-templates.md5"
  fi
  if ! md5sum -c "$cache/$prefix-openapi.md5" >/dev/null; then
    invalid_cache=true
    md5sum "$BIN_DIR"/../openapi.yaml >"$cache/$prefix-openapi.md5"
  fi

  if [[ $invalid_cache == true ]]; then
    x.openapi-generator \
      "$spec" \
      "$gen_out_dir" \
      "$template_dir"
  fi
}

# Run post-generation scripts on the internal package.
x.postgen() {
  cache="$1"
  mkdir -p "$cache"
  go build -o postgen "$PWD"/cmd/postgen/main.go
  POSTGEN_CACHE="$cache" ./postgen
  mv "$GEN_OUT_DIR"/gen/api_*.go "$cache/" 2>/dev/null || true
}

# Generate type-safe Go code from SQL.
x.generate.sqlc() {
  bin/scripts/sql-format.sh
  { cd $PG_REPO && sqlc generate && cd -; } || { echo "Failed sqlc generation" && exit 1; }
}

# Automatically generate CRUD and By queries based on existing indexes from
# a Postgres schema. Does not work with a schema file, database must be up to date.
x.generate.xo() {
  (
    source "$ENV_FILE"
    mkdir -p $PG_REPO/gen/crud
    xo schema "postgres://$POSTGRES_USER:$POSTGRES_PASSWORD@$POSTGRES_SERVER:$DB_PORT/$POSTGRES_DB?sslmode=disable" \
      -o $PG_REPO/gen/crud
  )
}

# Apply bundle overrides on Swagger UI.
x.sync-swagger-ui() {
  cp internal/static/swagger-override/swagger-initializer.js internal/static/swagger-ui/
  cp "$SPEC" "$PWD"/internal/static/swagger-ui
}

# Generate mocks for specified interfaces.
x.generate.counterfeiter() {
  # This shouldn't pose any problems, the interface is the only input to counterfeiter.
  cache="$1"

  envvar="internal/envvar/envvar.go"
  services="internal/handlers/services.go"

  if ! md5sum -c "$cache/counterfeiter.md5" >/dev/null; then
    counterfeiter -o internal/envvar/envvartesting/provider.gen.go $envvar Provider &
    counterfeiter -o internal/handlers/handlerstesting/authorization.gen.go $services AuthorizationService &
    counterfeiter -o internal/handlers/handlerstesting/authentication.gen.go $services AuthenticationService &
    md5sum $envvar $services >"$cache/counterfeiter.md5" &
    wait
  fi
}

# Run all codegen and postgen commands for the project.
x.generate() {
  # TODO --force-regen to any x fn removes all cache dirs
  echo "${MAGENTA}${BOLD}Running codegen and postgen...${OFF}"
  cache=".generate.cache"

  x.generate.api "$cache" "internal" "$SPEC" "$GEN_OUT_DIR" "$TEMPLATE_DIR"
  go generate ./... &
  x.generate.counterfeiter "$cache" &
  x.generate.sqlc &
  x.generate.xo &
  x.sync-swagger-ui &
  x.postgen "$cache" &
  wait
}

# Bring docker compose services up.
x.compose-up() {
  docker-compose up -d
}

# Test the entire project.
x.test() {
  x.compose-up
  x.generate
  create_test_database
  godotenv -f "$ENV_FILE" go test $@ ./...
}

# Test and build the entire project.
x.build() {
  x.test ""
  go build -o openapi-go-gin-postgres-sqlc "$PWD"/cmd/rest-server
}

# Test, build and run the entire project.
x.run() {
  x.build
  ./openapi-go-gin-postgres-sqlc -env="$ENV_FILE"
}

# Run the entire project with hot-reloading.
x.run-hot-reload() {
  x.compose-up
  air \
    --build.pre_build_cmd "bin/build generate" \
    --build.cmd "go build -o ./air-main ./cmd/rest-server/" \
    --build.bin "./air-main -env=$ENV_FILE" \
    --build.exclude_regex ".gen.go,internal/gen/*,$PG_REPO/gen/*,testdata,_test.go" \
    --build.stop_watch "internal/handlers/,internal/services/" \
    --build.delay 1000
}

# Ensure no breaking changes to the OpenAPI spec in the same version are present.
x.release() {
  x.diff-openapi-spec
}

# Wrapper for golang-migrate with predefined configuration.
x.migrate() {
  (
    source "$ENV_FILE"
    migrate \
      -path db/migrations/ \
      -database "postgres://$POSTGRES_USER:$POSTGRES_PASSWORD@$POSTGRES_SERVER:$DB_PORT/$POSTGRES_DB?sslmode=disable" \
      "$@"
  )
}

# Creates a new migration file with the given name.
x.migrate.create-migration() {
  tmp="$*"
  tmp="${tmp// /_}"
  name="${tmp,,}"
  [[ -z $name ]] && echo "Please provide a migration name" && exit
  x.migrate create -ext sql -dir db/migrations/ "$name"
}

create_test_database() {
  (
    source "$ENV_FILE"

    local postgres_test_db="${POSTGRES_DB}_test"

    drop_db "$postgres_test_db" .env

    echo "${BLUE}${BOLD}Stopping any running processes for database $postgres_test_db.${OFF}"
    docker exec -t postgres_db_"$PROJECT_PREFIX"_"$APP_ENV" \
      psql --no-psqlrc \
      -U "$POSTGRES_USER" \
      -d "$POSTGRES_DB" \
      -c "select pg_terminate_backend(pid) \
        from pg_stat_activity \
        where datname='$postgres_test_db'"
  )
}

############## openapi ##############

# Validates an OpenAPI specification.
x.validate() {
  java -jar openapi-generator-cli.jar validate -i "${1:-$SPEC}"
}

# Wrapper for openapi-generator with sane output modifications.
x.openapi-generator() {
  local spec="$1"
  local gen_out_dir="$2"
  local template_dir="$3"

  [[ -z $spec ]] && echo "openapi-generator: spec required" && exit 1
  [[ -z $gen_out_dir ]] && echo "openapi-generator: out dir required" && exit 1
  [[ -z $template_dir ]] && echo "openapi-generator: template dir required" && exit 1
  echo "Generating API from $spec"
  echo "Generation directory: $gen_out_dir"
  echo "Template override directory: $template_dir"

  rm -rf "$gen_out_dir/gen"
  # debug has a very small overhead compared to the >1s required per spec
  java -jar "$BIN_DIR"/../openapi-generator-cli.jar generate \
    -g go-gin-server \
    -i "$spec" \
    -o "$gen_out_dir" \
    -t "$template_dir" \
    --additional-properties=packageName=openapi,apiPath=gen,hideGenerationTimestamp=true \
    --enable-post-process-file \
    --global-property=debugModels,debugOperations >debug-openapi.log #>/dev/null \

  mkdir -p "$gen_out_dir"/gen/models
  mkdir -p "$gen_out_dir"/handlers
  mkdir -p "$gen_out_dir"/services
  mkdir -p "$gen_out_dir"/rest
  mv "$gen_out_dir"/gen/routers.go "$gen_out_dir"/rest
  mv "$gen_out_dir"/gen/model_*.go "$gen_out_dir"/gen/models 2>/dev/null || echo "No model files found. Skipping"
  rm -rf "$gen_out_dir/api"
}

# Run a diff against the previous OpenAPI spec in the main branch.
# Can also be used to generate changelogs when upgrading major versions.
x.diff-openapi-spec() {
  commit=2
  # use latest main commit as base if spec has not changed or in another branch
  git diff --exit-code "$SPEC" &>/dev/null && commit=1
  [[ $(git branch --show-current) != "main" ]] && commit=1

  commit_name="$(git log --oneline -- $SPEC | sed -n ${commit}p | awk '{print $1}')"
  base_spec="/tmp/openapi.yaml"
  git show "main@{$commit_name}:$SPEC" >"$base_spec"

  tmp="$(yq .info.version "$base_spec")"
  base_v="${tmp%%.*}"
  tmp=$(yq .info.version "$SPEC")
  rev_v="${tmp%%.*}"
  ((rev_v != base_v)) &&
    echo "${YELLOW}Revision mismatch $rev_v and $base_v, skipping diff.${OFF}" && return

  args="-format text -breaking-only -fail-on-diff"
  if oasdiff $args -base "$base_spec" -revision $SPEC; then
    echo "${GREEN}No breaking changes found in $SPEC.${OFF}"
  else
    echo "${RED}Breaking changes found in $SPEC.${OFF}"
  fi
}

usage() {
  declare -A x_funcs
  declare x_funcs_args docs
  local maxch=400

  for c in "${COMMANDS[@]}"; do
    shopt -s extdebug
    lns+=("$(declare -F x.$c | awk '{print $2}')")
    x_funcs_args+=("-")
    shopt -u extdebug
  done

  for i in ${!lns[@]}; do
    comment_line="$(head -$((${lns[$i]} - 1)) $0 |
      tac |
      sed -n '/#/!q;p' |
      tac |
      awk '{$1=$1;print}')"
    # TODO keep separate arrays for comments and args as with --x-options
    x_funcs["${COMMANDS[$i]}"]="$comment_line"
  done

  for i in "${!COMMANDS[@]}"; do
    comment="$(merge_comments "${x_funcs[${COMMANDS[$i]}]}")"
    docs+=("$(
      printf -- "%s\t%s\t%s" \
        "${COMMANDS[$i]}" \
        "${x_funcs_args[$i]}" \
        "$comment"
    )")
  done

  x_functions="$(column -t \
    --separator $'\t' \
    --output-width 100 \
    --table-noextreme C2 \
    --table-noheadings \
    --table-wrap C3 \
    --table-columns C1,C2,C3 < <(printf "    %s\n" "${docs[@]}"))"
  declare -A x_opts
  declare lns x_flags x_opts_args

  docs=()

  while IFS= read -r line; do
    x_flags+=("${line}")
  done < <(sed -nr 's/.*(--x-[[:alnum:]_-]+)\)/\1/p' $0)

  while IFS= read -r line; do
    lns+=("${line}")
  done < <(sed -nr '/.*(--x-[[:alnum:]_-]+)\)/=' $0)

  for i in ${!lns[@]}; do
    comment_line="$(tail -n +$((${lns[$i]} + 1)) $0 |
      sed -n '/^[[:blank:]]*#/!q;p' |
      awk '{$1=$1;print}')"
    x_opts["${x_flags[$i]}"]=$comment_line
  done

  for i in "${!x_opts[@]}"; do
    comment="$(merge_comments "${x_opts[$i]}")"
    x_opts_args+=("-")
    docs+=("$(
      printf -- "%s\t%s\t%s" \
        "$i" \
        "${x_opts_args[$i]}" \
        "$comment"
    )")
  done
  mapfile -t docs < \
    <(LC_COLLATE=C sort < <(printf "%s\n" "${docs[@]}"))
  x_options="$(column -t \
    --separator $'\t' \
    --output-width 100 \
    --table-noextreme C2 \
    --table-noheadings \
    --table-wrap C3 \
    --table-columns C1,C2,C3 < <(printf "    %s\n" "${docs[@]}") |
    GREP_COLORS='ms=1;32' grep -E --color "^[[:blank:]]{4}[[:alnum:][:punct:]]*|$")"
  printf "\n"

  cat <<EOF
$RED${BOLD}Usage: $(basename $0) [x.function] [--x-option ...] [args]$OFF

${BOLD}x.functions:$OFF
$(echo "${x_functions}" | sed -e 's/^\(.*\)$/'"$BLUE$BOLD"'\1'"$OFF"'/')

${BOLD}--x-options:$OFF
$(echo "${x_options}" | sed -e 's/^\(.*\)$/'"$GREEN$BOLD"'\1'"$OFF"'/')
EOF
}

merge_comments() {
  tmp="$1"
  tmp=${tmp//\#/}
  tmp=${tmp#* }
  comment=${tmp//$'\n'/}
  [[ -z $comment ]] && comment="-"
  ((${#comment} > maxch)) && comment="${comment:0:maxch}..."
  echo "$comment"
}

# --------------------- completion and delegation --------------------
#      `complete -C foo foo` > `source <(foo bloated_completion)`

while IFS= read -r line; do
  [[ $line =~ ^declare\ -f\ x\. ]] || continue
  COMMANDS+=("${line##declare -f x.}")
done < <(declare -F)
# sort the array. Mimic file input to sort
mapfile -t COMMANDS < \
  <(LC_COLLATE=C sort < <(printf "%s\n" "${COMMANDS[@]}"))

if [[ -n $COMP_LINE ]]; then
  x_fn=${COMP_LINE#* }
  pre="${COMP_LINE##* }" # the part after the last space in the current command
  cur_commands=(${COMP_LINE%"$pre"})

  for c in "${COMMANDS[@]}"; do
    # check if input matches c up to input length
    [[ ${c:0:${#x_fn}} == "${x_fn,,}" ]] && echo "$c"

    [[ "${c}" == "$x_fn" ]] && xfn_specified=1
  done

  [[ -n "$xfn_specified" ]] && exit

  declare -A x_opts_specified
  for cmd in "${cur_commands[@]}"; do
    for opt in ${!x_opts[*]}; do
      if [[ "$opt" == *"$cmd"* ]]; then
        x_opts_specified["$opt"]=1
        break
      fi
    done
    # if [[ "${x_opts[$cmd]+1}" ]]; then
    #   x_opts_specified["${cmd}"]=1
    #   break
    # fi
  done

  for opt in ${!x_opts[*]}; do
    [[ "${x_opts_specified[$opt]+1}" ]] && continue
    [[ ${opt:0:${#pre}} == "${pre,,}" ]] && echo "${opt}"
  done

  exit
fi

# First comment lines automatically added to usage docs.
for arg in "$@"; do
  shift
  case $arg in
  --x-force-regen)
    # Removes generation cache, forcing a new run.
    force_regen=1
    ;;
  --x-no-confirmation)
    # Bypasses confirmation messages.
    no_confirmation=1
    ;;
  *) set -- "$@" "$arg" ;;
  esac
done

# handle executing x functions
if [[ -n "$1" ]]; then
  declare CMD="$1"
  shift
  for c in "${COMMANDS[@]}"; do
    declare cmd=$(command -v "x.$c")
    if [[ $c == "$CMD" && -n "$cmd" ]]; then
      "x.$CMD" "$@"
      exit $?
    fi
  done
fi

usage
